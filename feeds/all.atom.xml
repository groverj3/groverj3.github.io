<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jeff Grover. Bioinformatician.</title><link href="https://groverj3.github.io/" rel="alternate"></link><link href="https://groverj3.github.io/feeds/all.atom.xml" rel="self"></link><id>https://groverj3.github.io/</id><updated>2019-06-25T00:00:00-07:00</updated><subtitle>Bioinformatician/Ph.D. Candidate&lt;br&gt;
&lt;a href="https://cals.arizona.edu/research/mosherlab/Mosher_Lab/Home.html" target="_blank"&gt;The Mosher Lab&lt;/a&gt;
@ &lt;a href="https://www.arizona.edu/" target="_blank"&gt;The University of Arizona&lt;/a&gt;</subtitle><entry><title>Managing Software on a Multiuser Linux System</title><link href="https://groverj3.github.io/articles/2019-06-25/managing-software-on-a-multiuser-linux-system.html" rel="alternate"></link><published>2019-06-25T00:00:00-07:00</published><updated>2019-06-25T00:00:00-07:00</updated><author><name>Jeffrey Grover</name></author><id>tag:groverj3.github.io,2019-06-25:/articles/2019-06-25/managing-software-on-a-multiuser-linux-system.html</id><summary type="html">&lt;p&gt;When I started my Ph.D. I had a good amount of experience working in a Linux
environment on my own computers. Mostly as a hobby. My advisor had bought a small
server several years previous for a post-doc's project and I was offered this
system to use for my …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When I started my Ph.D. I had a good amount of experience working in a Linux
environment on my own computers. Mostly as a hobby. My advisor had bought a small
server several years previous for a post-doc's project and I was offered this
system to use for my day-to-day work. It doesn't set any speed records, but it
&lt;em&gt;is&lt;/em&gt; a 24 thread system with 75gb of RAM and 12TB of storage. This makes it
perfect for running analyses that I wouldn't want to do on my laptop, but need to
be tweaked repeatedly and therefore are awkward to run on the university HPC. I
also use this server for jupyter notebooks and it still handles a few users at
a time well.&lt;/p&gt;
&lt;p&gt;Since this system was starting from a blank slate I decided to implement some
simple rules for system management. When I started out I was the only user, but
since then we've added several others and this plan has held up. This is going to
be heavily biased toward running a small server for computational work that's
shared between &amp;lt; 10 users, because that's what I do.&lt;/p&gt;
&lt;p&gt;These are ordered, but feel free to ignore that. They're really more like general
tips.&lt;/p&gt;
&lt;h3&gt;0. Run a Well-Supported (Popular) Linux Server Distro&lt;/h3&gt;
&lt;p&gt;I know, I know, I know. You may have a favorite Linux distribution. It might be
&lt;a href="https://getfedora.org/"&gt;Fedora&lt;/a&gt;, or &lt;a href="https://linuxmint.com/"&gt;Mint&lt;/a&gt;, or
&lt;a href="https://manjaro.org/"&gt;Manjaro&lt;/a&gt; (that's what I've been using). You might use
&lt;a href="https://www.archlinux.org/"&gt;Arch&lt;/a&gt;, you might be a &lt;a href="https://www.gentoo.org/"&gt;masochist&lt;/a&gt;,
or you may enjoy running something with an innovative package management system
like &lt;a href="https://www.gnu.org/software/guix/"&gt;Guix&lt;/a&gt; or &lt;a href="https://nixos.org/"&gt;NixOS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Maybe you just don't know why everyone uses this *nix stuff and don't know why
you can't just bioinformatics in Excel.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/images/clippy_bioinfo.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;You're welcome to use something flashier, but I'd recommend sticking to Ubuntu
Server or CentOS. Fedora Server might also be a good choice. Especially with
Ubuntu potentially not shipping 32bit support in the future. For those with more
time or inclination to fiddle around, Debian would also make a good research
computing environment. The reason for this is that most software that's already
packaged will be either in .deb (Debian and derivate, including Ubuntu) or .rpm
(Redhat, Fedora, SUSE) format. Can you extract these packages and install them on
other systems? Sure. Are you going to want to do that every time you update
stuff. No.&lt;/p&gt;
&lt;p&gt;You also want to make sure that required libraries for software you may need to
compile are available without much fussing around straight from the repositories.
You'll have to do enough annoying things. Don't make this annoying.&lt;/p&gt;
&lt;h3&gt;1. Revoke Other Users' &lt;strong&gt;sudo&lt;/strong&gt; Privileges&lt;/h3&gt;
&lt;p&gt;This may seem obvious but you'd be surprised how many academic labs don't think
about this on their private server (if they have one). It's hard to overstate the
terrible time you'll have as a sysadmin if another one of your users types the
dreaded:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo rm -r /
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo rm -r /*
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's easy to forget that "." before the "/". &lt;/p&gt;
&lt;p&gt;Or, less catasrophically, that user may try installing software in a brittle way.
Meaning, you, the humble pseudo-sysadmin who's not actually getting paid for
sysadmin tasks, will have to spend time fixing it.&lt;/p&gt;
&lt;p&gt;All it takes is for you, the SUPER USER, the GOD OF THE SERVER, to run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo deluser &lt;span class="o"&gt;{&lt;/span&gt;USERNAME&lt;span class="o"&gt;}&lt;/span&gt; sudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Replace {USERNAME} with the user to remove.&lt;/p&gt;
&lt;h3&gt;2. Don't Blindly Install Software From Your Distro's Repos&lt;/h3&gt;
&lt;p&gt;I did just say to pick a distro with lots of stuff in the repos, right? Yes, but
particularly in scientific/research computing you really really really can't
assume these repos are anything close to up-to-date. Don't be afraid to download
the source code and compile, or even easier, there is likely a prebuilt
binary release available on the project's github.&lt;/p&gt;
&lt;p&gt;As an example, if you're running the most recent LTS version of Ubuntu (18.04)
then the version of samtools available to you is v1.7 which is a year and a half
old at the time of writing. If you have control of the system, then at least try
to install the most recent stable versions of critical software.&lt;/p&gt;
&lt;h3&gt;3. Use an Easily Followed Convention for Manual Software Installation&lt;/h3&gt;
&lt;p&gt;When you need to download software and install it manually put it somewhere easy
to remember, and easy to find for others. I put manually installed software in
/opt/software_version and symlink the binaries to /usr/local/bin/. This way,
you quickly know what you have manually installed, and what version they are just
from the directory structure. You also make everything available in the $PATH and
runnable with just the program name.&lt;/p&gt;
&lt;p&gt;The worst thing that can happen in a broken symlink if you change software
versions, and that's an easy fix with a:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ln -s /path/to/binary /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4. Encourage Users To Test Software in ~/bin&lt;/h3&gt;
&lt;p&gt;Create a private bin directory inside each user's home folder. This is often
pre-configured in each user's path. If not you'll need to add it to each user's
.bashrc or .profile or .bash_profile, depending on which is the preferred method
for your distro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# set PATH so it includes user&amp;#39;s private bin if it exists&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -d &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/bin&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/bin:&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let your users test and if multiple people need it, or they're running something
all the time, then you can install it system-wide in /opt.&lt;/p&gt;
&lt;h3&gt;5. Encourage Python Users to Set Up &lt;a href="https://github.com/pyenv/pyenv"&gt;pyenv&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux systems use Python under the hood a lot. Much of the system depends on
python, and your distro's package manager has already likely installed many
python packages. However, these versions are likely old and frozen at the version
number that shipped with the OS. I dislike running software that is &lt;em&gt;years&lt;/em&gt; out
of date. Python's package management with pip is kind of a mess and it doesn't
know which packages are needed by the system, and which are installed with it.
This is improving over time, but it's still not good.&lt;/p&gt;
&lt;p&gt;To avoid this, users should install the most recent stable version of Python.
Pyenv gives you a relatively easy and very lightweight way to do this. It also
allows the system packages to coexist peacefully in the root directory so it's
harder to break things. Plus, the users get the latest Python features.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/pyenv/pyenv"&gt;pyenv github&lt;/a&gt; has relatively easy to follow
instructions.&lt;/p&gt;
&lt;h3&gt;6. Use User-specific Language Libraries/Packages&lt;/h3&gt;
&lt;p&gt;This pops up for us with both python and R. It boils down to never, ever, using:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo pip install &lt;span class="o"&gt;{&lt;/span&gt;PACKAGE_NAME&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;
&lt;span class="nf"&gt;install.packages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;PACKAGE_NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If users can't use sudo there's no danger here anyway, but using user-specific
libraries and packages keeps things consistent. It also means that, once again,
you don't have to manage something. The following will solve this for Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install --user &lt;span class="o"&gt;{&lt;/span&gt;PACKAGE_NAME&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This installs packages to ~/.local/lib/python{VERSION}/site-packages &lt;/p&gt;
&lt;p&gt;R requires a bit more doing. To create a user-library I recommend creating a
.Renviron in each user's home directory and adding the following to it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# .Renviron is run every time a new R session is started&lt;/span&gt;
&lt;span class="c1"&gt;# Use .Renviron to set environment variables for R&lt;/span&gt;

&lt;span class="c1"&gt;# Use the local R library&lt;/span&gt;
&lt;span class="n"&gt;R_LIBS_USER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;~/.local/lib/R/site-library&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Wrapping up&lt;/h3&gt;
&lt;p&gt;In summary, administering a small multi-user system doesn't have to be
complicated. You do want to minimize the ability for your users to break things
though. By no means is this an exhaustive guide, but it might help you out if
you're wondering where to start.&lt;/p&gt;
&lt;p&gt;Despite the proliferation of HPC systems at Universities, and cloud computing in
enterprise environments, a smaller server for your research group is still a
good investment in 2019. Submitting jobs to a queue is fine when you're not doing
iterative work, but if you want to quickly test things it gets old really quick.
Likewise, you can easily get hardware on-par with a remote VM and it's more
readily accessed.&lt;/p&gt;
&lt;p&gt;Tune in next time for something more bioinformatics-focused!&lt;/p&gt;</content><category term="sysadmin"></category></entry><entry><title>Setting up a Static Site With Pelican and GitHub Pages</title><link href="https://groverj3.github.io/articles/2019-06-15/setting-up-a-static-site-with-pelican-and-github-pages.html" rel="alternate"></link><published>2019-06-15T00:00:00-07:00</published><updated>2019-06-15T00:00:00-07:00</updated><author><name>Jeffrey Grover</name></author><id>tag:groverj3.github.io,2019-06-15:/articles/2019-06-15/setting-up-a-static-site-with-pelican-and-github-pages.html</id><summary type="html">&lt;p&gt;In an effort to aid in my future job searching I decided I needed a
personal/professional website. It needed to look good, contain links to my
relevant social and job-search profiles, host some examples of work from my Ph.D.
, showcase my skillset, and host my CV. GitHub pages …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In an effort to aid in my future job searching I decided I needed a
personal/professional website. It needed to look good, contain links to my
relevant social and job-search profiles, host some examples of work from my Ph.D.
, showcase my skillset, and host my CV. GitHub pages seemed like a natural fit,
since I already share most of my work there. GitHub recommends static site
generation with Jekyll, which I've seen to be a fine way to do that, and they
have integrated tools for working with it. However, I mostly write python
day-to-day (and R) and the idea of using a ruby-based framework for this just
seemed silly to me. So, stubborn as I am, I decided to embark on a quest to use a
python-based alternative. Pelican seemed to be the most actively developed, so I
went ahead with that.&lt;/p&gt;
&lt;p&gt;The issue I ran into is that many of the guides were unnecessarily complicated, 
or didn't contain information for my particular use-case. So, I've compiled here
the steps I used to generate this site, in the hope that it will help others.&lt;/p&gt;
&lt;h3&gt;Note Before Starting&lt;/h3&gt;
&lt;p&gt;Before starting here, I would like to mention that I will not be recommending
using a virtual environment. Why? This is overkill for a simple static site/blog
and adds unnecessary complication to a process that doesn't need to be hard at
all. These sorts of instructions are useful for more advanced deployments, and if
you need them then you probably don't need a guide as simplified as this anyway.&lt;/p&gt;
&lt;p&gt;Personally, I &lt;strong&gt;do&lt;/strong&gt; use &lt;a href="https://github.com/pyenv/pyenv"&gt;pyenv&lt;/a&gt; to manage python
installations on my home and work computers, and well as our lab server. It makes
my life much easier. But it is not &lt;strong&gt;required&lt;/strong&gt; so I won't be going over it here.&lt;/p&gt;
&lt;p&gt;I still recommend installing python packages at the user level though. Mostly a
*nix/macOS thing, I'm pretty sure Windows peeps can ignore this. This will be
explained where relevant.&lt;/p&gt;
&lt;p&gt;This guide will be GNU/Linux centric and I'm not apologizing for it :)&lt;/p&gt;
&lt;p&gt;Don't use Python 2.x, it's 2019. I'm writing these with Ubuntu and derivatives in
mind, so I will specify python3 throughout, since I believe &lt;code&gt;python&lt;/code&gt; still points
to 2.7.&lt;/p&gt;
&lt;h3&gt;Step-by-step Instructions Start Here:&lt;/h3&gt;
&lt;p&gt;Like I said above, there are existing guides for this. However, most of them
recommend installing what amounts to extreme overkill for simple GitHub pages.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Have Python and PIP Installed&lt;/p&gt;
&lt;p&gt;If you're on Linux then congrats, you've already got it. If not, consult the
docs at &lt;a href="https://www.python.org/"&gt;python.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;However, you may not have pip, the python package manager. For that check by
running:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which pip3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If it doesn't point to an executable then you'll need to run (Ubuntu-based):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt install python3-pip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For other distros/package managers or macOS with homebrew consult the docs to
get the specific commands. These will likely require superuser/administrator
privileges.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install Pelican&lt;/p&gt;
&lt;p&gt;On any *nix or macOS machine the following should do the trick in  or
other terminal:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip3 install --user pelican ghp-import Markdown typogrify&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;--user&lt;/code&gt; flag installs Pelican to your home directory and doesn't require
super-user/administrator privileges and &lt;code&gt;ghp-import&lt;/code&gt; will allow you to push
directly to github.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a New GitHub Repo and Clone&lt;/p&gt;
&lt;p&gt;It's perfectly fine to use the web interface to create a new repo, so go to
your github homepage and create a new repository with the name:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{username}.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is important, and will allow you to access your site at
{username}.github.io rather than needing extra bits on the end of your github
url. Initializing with a README and LICENSE is up to you! May I recommend the
MIT license for simplifcity and FOSSness?&lt;/p&gt;
&lt;p&gt;Go to your desired dev folder on your machine, I keep all github projects in
"~/Github/{project_name}", and clone:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd {project_folder} &amp;amp;&amp;amp; git clone {repo.git}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run Pelican Quickstart in Your Repo Directory&lt;/p&gt;
&lt;p&gt;Pelican comes with a handy quickstart script. Though, it's not terribly-well
documented. My settings were as follows. Only non-defaults listed (for 
defaults just push enter):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pelican quick-start&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do you want to specify a URL prefix? Y (Followed by: 
{https://{username}.github.io})&lt;br&gt; 
What is your time zone? {insert local timezone here}&lt;br&gt;
Do you want to upload your website using GitHub Pages? Y&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This will create the skeleton of your page, and allow you start adding
content! Other things can be changed later in your config files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a First Post&lt;/p&gt;
&lt;p&gt;By default, things created in your root level directory are turned into blog
posts. Don't ask me why this is the default, I don't like it. However, this
can be changed/hacked around later. For now create a file called &lt;code&gt;test.md&lt;/code&gt;.
Add the following to it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Title: This is a Blog Post!&lt;br&gt;
Date: 2019-06-15&lt;br&gt;
Category: Article&lt;/p&gt;
&lt;p&gt;Hello World!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate Your Site&lt;/p&gt;
&lt;p&gt;There are several ways to do this, this is the simplest:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make devserver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This command starts a dev server, which automatically updates the generated
content in real-time. So you can edit and preview simultaneously. Point your
web browser of choice to &lt;code&gt;localhost:8000&lt;/code&gt; and take a look!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a Static Page&lt;/p&gt;
&lt;p&gt;By default, things in the root directory are blog posts (configurable), but
you'll probably want some static pages that are always linked to and don't
contain blog content. For that, without stopping the devserver, create a
new folder inside the "content" subdirectory called "pages":&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir ./content/pages&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create a new markdown document in there called "about.md":&lt;/p&gt;
&lt;p&gt;&lt;code&gt;touch ./content/pages/about.md&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Fill this with the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Title: About&lt;br&gt;
Date: 2019-06-14&lt;/p&gt;
&lt;p&gt;Hello world! This is a test, using Pelican to create a github pages site.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preview Your New Pages&lt;/p&gt;
&lt;p&gt;Go back to your browser, which should have been running the whole time, and
refresh on &lt;code&gt;localhost:8000&lt;/code&gt;. You should now see options to go to a new page
called "about." That's it! Easy peasy!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate Your Content and Push&lt;/p&gt;
&lt;p&gt;Kill the devserver with ctrl + c. Run the following in your root directory:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is probably unnecessary, but in case the devserver wasn't working
correctly, then this ensures you will have no issues.&lt;/p&gt;
&lt;p&gt;Next, run the following to push to github:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make github&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This will ask for your github username and password, then pushes to your
repo.&lt;/p&gt;
&lt;p&gt;Now direct your browser to:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://{username}.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You site should be visible now!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Push Your Source Code to a New Branch&lt;/p&gt;
&lt;p&gt;This method of pushing creates a problem from a dev standpoint. It will write
over all content in your repo every time. Plus, it only writes the rendered
site there. If you want to work on things off this same machine, you're going
to want to push the source code. Fortunately, there's an easy workaround for
this.&lt;/p&gt;
&lt;p&gt;Go to the GitHub web interface and create a new branch called "source". This
will copy all current content to it, which is just the rendered page. Now,
back in your development folder, copy all content from your repo's folder
elsewhere (non-hidden stuff only). Then, open a terminal and type:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This switches you to the source branch. It also replaces the contents with
the rendered content-only.&lt;/p&gt;
&lt;p&gt;Delete the contents again and replace with your copy of the source code.
Now enter:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add . &amp;amp;&amp;amp; git commit -m "Pushed source" &amp;amp;&amp;amp; git push -f origin source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This will force a push to the source branch. Technically you don't need the
"origin source" since you've checked it out, but for extra safety since we're
already doing something that is frowned on. This will totally overwrite your
site's content with the source code used to generate it. But only on that
branch. Now you can push using the &lt;code&gt;make github&lt;/code&gt; command, which defaults to
the master branch, when you want to publish, and push with &lt;code&gt;git push origin
source&lt;/code&gt; when you want to update the source code.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Final Thoughts&lt;/h3&gt;
&lt;p&gt;You're now done! And you can switch between branches to see the source and output
from Pelican's rendering. I'll make another post later to detail some more
configuration details. Until then, the &lt;a href="https://docs.getpelican.com"&gt;docs&lt;/a&gt; are a
wonderful resource.&lt;/p&gt;</content><category term="tutorial"></category><category term="pelican"></category></entry></feed>